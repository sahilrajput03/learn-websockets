<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta http-equiv="X-UA-Compatible" content="IE=edge" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<!-- <script src="https://cdn.socket.io/4.5.0/socket.io.min.js" integrity="sha384-7EyYLQZgWBi67fBtVxw60/OWl1kjsfrPFcaU0pp0nAh+i8FD068QogUvg85Ewy1k" crossorigin="anonymous"></script> -->
		<script src="/socket.io/socket.io.js"></script>
		<title>Document</title>
		<script>
			window.onload = () => {
				const POTENTIAL_MESSAGES_LIST = []
				const FAILED_MESSAGE_SUFFIX = 'ðŸ”´Failed: Waiting for internet connection..'

				// io object is available globally bcoz we linked `socket.io` script from cdn.
				let {hostname, port} = window.location
				// ALERT: In below websocket address using 'wss' instead of 'ws' is necessary when deployed to heroku. YO!!

				let socketAddress = hostname === 'localhost' ? `ws://${hostname}:${port}` : `wss://${hostname}:${port}`

				const socket = io(socketAddress)
				window.socket = socket // for making it accessible by browser console for debugging

				/**
				 * Getting name from 'name' event and setting it in dom #############################################################################
				 */
				//
				// (BELOW WORKS VERY GOOD THOUGH but removed in favor of getting realistic name from 'name' event from server)
				// Adding `name` to dom
				// socket.on('connect', () => {
				// Faking it from `socket.id`
				// 	document.querySelector('#name').innerHTML = socket.id.substr(0, 2)
				// })
				//
				socket.on('join', (payload) => {
					const {clientName, clientId, currentConnections} = payload

					if (payload.clientId === socket.id) {
						document.querySelector('#name').innerHTML = clientName
						window.clientName = clientName
					} else {
						// PUSH TO CHATBOX
						const el = document.createElement('div')
						el.innerHTML = 'ðŸ‘‹ ' + clientName + ' connected to chat. Say Hi to ' + clientName + '..'
						document.querySelector('#messages-container').appendChild(el)
					}

					const allClients = Object.values(currentConnections).join(', ')
					console.log({allClients})

					// Add current users to a online section to show update online people
					const el = document.querySelector('#online')
					el.innerHTML = allClients
				})

				/**
				 * Receiving message LOGIC
				 * =======================
				 */
				socket.on('message', (payload) => {
					let {clientId, clientName, message} = payload

					// Using 'You' identifier if the message belong to current user:
					if (clientId === socket.id) {
						clientName = 'You'

						/**
						 * Clearning network failed messages
						 */
						// Utility function to get last n items from an array
						const nLastItems = (arr, n) => arr.slice(Math.max(arr.length - n, 0))

						// POTENTIAL_MESSAGES_LIST
						// Get list of last 100 messages and filter network failed messages from those only coz filtering from all the messages can be perf bottleneck.

						const N = 100
						const nodeList = document.querySelector('#messages-container').querySelectorAll('div')
						const recentMessages = nLastItems(Array.from(nodeList), N) // conversion of nodelist to array is important else error is thrown i.e, ```NodeList.slice() is not a function```.

						recentMessages
							.filter((el) => el.innerHTML.endsWith(FAILED_MESSAGE_SUFFIX))
							.forEach((element) => {
								// src: https://www.javascripttutorial.net/dom/manipulating/remove-a-dom-element/
								document.querySelector('#messages-container').removeChild(element)
							})
					}

					// PUSH TO CHATBOX
					const el = document.createElement('div')
					el.innerHTML = clientName + ': ' + message
					document.querySelector('#messages-container').appendChild(el)
				})

				/**
				 * Sending message LOGIC
				 * =====================
				 */
				const sendMessg = () => {
					const messg = document.querySelector('input').value
					socket.emit('message', messg)
					document.querySelector('input').value = ''

					const potentialMessage = 'You' + ': ' + messg + '&nbsp;'.repeat(3) + FAILED_MESSAGE_SUFFIX // coz initially message is local only.
					POTENTIAL_MESSAGES_LIST.push(potentialMessage)

					//! SHOWS LIKE GREY TICK i.e, not confirmed on server state.
					// PUSH TO CHATBOX
					const el = document.createElement('div')
					el.innerHTML = potentialMessage
					document.querySelector('#messages-container').appendChild(el)
				}
				// ATTACH to Send button click (not using send buttton anymore infavor of direct `Enter` key)
				// document.querySelector('#btn-send').onclick = sendMessg
				//
				// ATTACH to `Enter` button event
				document.querySelector('input').onkeydown = (e) => {
					if (e.key === 'Enter') {
						sendMessg()
					}
				}

				/**
				 * Get notified when any user exit
				 */
				socket.on('exit', (payload) => {
					const {clientId, clientName} = payload

					// PUSH TO CHATBOX
					const el = document.createElement('div')
					el.innerHTML = 'ðŸš¶ ' + clientName + ' left the chat'
					document.querySelector('#messages-container').appendChild(el)
				})
			}
		</script>
	</head>
	<body style="text-align: center">
		<h2>Group Chat App</h2>

		<section>
			<span class="bold">You:</span>
			<span id="name"></span>
		</section>

		<section>
			<span class="bold">Online:</span>
			<span id="online"></span>
		</section>

		<section>
			<div class="bold">CHAT BOX</div>
			<div id="messages-container"></div>
		</section>

		<input placeholder="message" />
		<!-- <button id="btn-send">Send</button> -->

		<div>(Press Enter key to send)</div>

		<style>
			section {
				margin-bottom: 30px;
			}
			.bold {
				font-weight: bold;
			}
		</style>
	</body>
</html>
