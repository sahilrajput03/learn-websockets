<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta http-equiv="X-UA-Compatible" content="IE=edge" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<!-- <script src="https://cdn.socket.io/4.5.0/socket.io.min.js" integrity="sha384-7EyYLQZgWBi67fBtVxw60/OWl1kjsfrPFcaU0pp0nAh+i8FD068QogUvg85Ewy1k" crossorigin="anonymous"></script> -->
		<script src="/socket.io/socket.io.js"></script>
		<title>Document</title>
		<script>
			window.onload = () => {
				// const POTENTIAL_MESSAGES_LIST = []
				let typingStatus = false
				const typingStatusIds = []
				const FAILED_MESSAGE_SUFFIX = 'ðŸ”´' // Failed: Waiting for internet connection..

				// ::STATUS:: 1. SENT, 2. SYNCED TO OTHER DEVICE, 3. SEEN
				const icons = ['âœ”', 'âœ…', 'ðŸ‘€'] // Source: https://unicode-table.com/en/

				// io object is available globally bcoz we linked `socket.io` script from cdn.
				let {hostname, port} = window.location
				// ALERT: In below websocket address using 'wss' instead of 'ws' is necessary when deployed to heroku. YO!!

				let socketAddress = hostname === 'localhost' ? `ws://${hostname}:${port}` : `wss://${hostname}:${port}`

				const socket = io(socketAddress)
				window.socket = socket // for making it accessible by browser console for debugging

				/**
				 * Show body only when connection is successful
				 */
				socket.on('connect', () => {
					document.body.style.display = 'block'
				})

				/**
				 * `Join` event helps to get name for ourselves and get notification when somebody else joins
				 */
				socket.on('join', (payload) => {
					const {clientName, clientId, currentConnections} = payload

					if (payload.clientId === socket.id) {
						document.querySelector('#name').innerHTML = clientName
						window.clientName = clientName
					} else {
						// Send to chatbox
						sendToChatBox('notification', 'ðŸ‘‹ ' + clientName + ' joined. Say Hi to ' + clientName + '..')
					}

					updateOnlinePeopleSection(currentConnections)
				})

				/**
				 * Receiving message LOGIC
				 * =======================
				 */
				socket.on('message', (payload) => {
					let {clientId, clientName, message} = payload

					// Using 'You' identifier if the message belong to current user:
					if (clientId === socket.id) {
						clientName = 'You'

						/**
						 * Clearning network failed messages
						 */
						clearNetworkFailedMessages()
					}

					// Send to chatbox
					sendToChatBox(clientId, clientName + ': ' + message)
				})

				/**
				 * Sending message LOGIC
				 * =====================
				 */
				const sendMessg = () => {
					const messg = document.querySelector('input').value
					socket.emit('message', messg)
					document.querySelector('input').value = ''

					const potentialMessage = 'You' + ': ' + messg + '&nbsp;'.repeat(3) + FAILED_MESSAGE_SUFFIX // coz initially message is local only.
					// POTENTIAL_MESSAGES_LIST.push(potentialMessage)

					// let id = setTimeout(() => {

					// }, 1_000);

					//! SHOWS LIKE GREY TICK i.e, not confirmed on server state.
					// Send to chatbox
					sendToChatBox(socket.id, potentialMessage)
				}
				// ATTACH to Send button click (not using send buttton anymore infavor of direct `Enter` key)
				// document.querySelector('#btn-send').onclick = sendMessg
				//
				// ATTACH to `Enter` button event
				let notified = false
				let TIME_GAP = 3_000
				const SEND_TYPING_EVENT = () => socket.emit('typing', TIME_GAP)
				document.querySelector('input').onkeydown = (e) => {
					if (e.key === 'Enter') {
						sendMessg()
					} else {
						if (!notified) {
							console.log('sent typing..')
							SEND_TYPING_EVENT()

							setTimeout(() => {
								SEND_TYPING_EVENT()
								notified = false
							}, TIME_GAP)
						}
						notified = true
					}
				}

				/**
				 * Get notified when any user exit
				 */
				socket.on('exit', (payload) => {
					const {clientId, clientName, currentConnections} = payload

					// Send to chatbox
					sendToChatBox('notification', 'ðŸš¶ ' + clientName + ' left the chat')

					updateOnlinePeopleSection(currentConnections)
				})

				/**
				 * Get typing status
				//  Below logic works the best possible way it can! ~ Sahil
				 */
				let timer
				let who = []
				socket.on('typing', (payload) => {
					clearTimeout(timer)
					const {clientName, clientId, TIME_GAP} = payload

					// Pushing client to to ```who```  for TIME_GAP period
					if (who.indexOf(clientName) < 0) who.push(clientName)

					const el = document.querySelector('.typing')
					// const label = clientName + ' is typing..'
					const auriliaryVerb = who.length === 1 ? ' is' : ' are'
					const label = who.join(', ') + auriliaryVerb + ' typing..'
					el.innerHTML = label
					// console.log(label)

					timer = setTimeout(() => {
						el.innerHTML = ''
						who = []
						console.log('cleared')
					}, TIME_GAP)
				})

				/**
				 *
				 * OTHER UTILITY FUNCTIONS
				 *
				 */

				/**
				 * 1. Clearn failed network messages - UTILITY FUNCTION
				 */
				function clearNetworkFailedMessages() {
					// Utility function to get last n items from an array
					const nLastItems = (arr, n) => arr.slice(Math.max(arr.length - n, 0))

					// POTENTIAL_MESSAGES_LIST
					// Get list of last 100 messages and filter network failed messages from those only coz filtering from all the messages can be perf bottleneck.

					const N = 100
					const nodeList = document.querySelector('#messages-container').querySelectorAll('div')
					const recentMessages = nLastItems(Array.from(nodeList), N) // conversion of nodelist to array is important else error is thrown i.e, ```NodeList.slice() is not a function```.

					recentMessages
						.filter((el) => el.innerHTML.endsWith(FAILED_MESSAGE_SUFFIX))
						.forEach((element) => {
							// src: https://www.javascripttutorial.net/dom/manipulating/remove-a-dom-element/
							document.querySelector('#messages-container').removeChild(element)
						})
				}

				/**
				 * 2. Send to chatbox - UTILITY FUNCTION
				 */
				function sendToChatBox(clientId, message) {
					if (message === '') return

					const el = document.createElement('div')
					el.innerHTML = message

					if (clientId === 'notification') {
						el.style.textAlign = 'center'
					} else if (socket.id === clientId) {
						el.style.textAlign = 'right'
					} else {
						el.style.textAlign = 'left'
					}

					document.querySelector('#messages-container').appendChild(el)
				}

				/**
				 * 3. Set or Update Online people section - UTILITY FUNCTION
				 */
				function updateOnlinePeopleSection(currentConnections) {
					// Remove self (coz we'll add `You` later..)
					delete currentConnections[socket.id]

					const allClients = Object.values(currentConnections).join(', ')
					const el = document.querySelector('#online')
					el.innerHTML = allClients + ` and ${window.clientName} (You)`
					// console.log({allClients})
				}
			}
		</script>
	</head>
	<body style="text-align: center">
		<h2>Group Chat App</h2>

		<section>
			<span class="bold">You:</span>
			<span id="name"></span>
		</section>

		<section>
			<span class="bold">Online:</span>
			<span id="online"></span>
		</section>

		<section>
			<div class="bold">CHAT BOX</div>
			<div id="messages-container"></div>
		</section>

		<div class="typing"></div>
		<input placeholder="message" />
		<!-- <button id="btn-send">Send</button> -->

		<div>(Press Enter key to send)</div>

		<!-- STYLES HERE -->
		<style>
			body {
				/* I show body only when socket connection is successful. */
				display: none;
			}
			section {
				width: 300px;
				margin: auto;
				margin-bottom: 30px;
			}
			.bold {
				font-weight: bold;
			}
			.typing {
				font-style: italic;
				color: grey;
			}
		</style>
	</body>
</html>
